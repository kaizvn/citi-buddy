# Implementation

## Introduction
  Since I cannot handle all the ideas in my brain cell, so I write down them here.

## The challenge 
  Implement a simple application which organizes data for a city. It should store data for the cityâ€™s water supply, electricity and waste. All three need to be tracked with own attributes (which you can define creatively in a way it makes sense to you). 

  At least one of the data streams should come in through integration, one should be uploaded and one should be entered manually. The user should be able to analyze the data on some UI. All implemented features should be covered by automated tests.

## Techstack and Tools
  Techstack: **ReactJS**(client), NodeJS (server), **Sqlite3** (database).
  
  Base on timeline and requirements, I do pick some available tools that  help to maximize productivity and quickly release MVP then POC.
  - [Next.JS](https://nextjs.org): Main Framework to develop Application with React UI, help to handle routing.
  - [v0](https://v0.dev): V0 by Vercel(creator of Next.JS), a v0 is a powerful tool for generating high quality UIs and code. Most components of the project are generated by v0.
  - [prisma ORM](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm): lightning speed to create, modify and manage relationships of db, handle and type-safe query builder.
  - Others: [TailwindCSS]() for styling, [Playwright]() for e2e testing.


## Approach
The challenge scope is open with a lot of uncertainty, so that Bottom-Up is feasible approach in this case. V0 is game-changer to support me to do UI-First development.
  

## Roadmap
    
- [x] Targeting to deliver a POC that manage Public Utilities of the City: create new data manually input or by streaming *.csv file upload and stream files via URL.
- [ ] Design Database relationship and metadata API to be able to expose any 3rd party services.
- [ ] Design API to support querying data safe and sound, fast and light.
    

## Problems
Come across the requirements and after having an overview the big picture while develop UI to input data, I acknowledge main problems that need to be solved:
- DataLog of each Utility which are imported from other sources in different forms, which we may not standardize or take effort to maintain new DataLog structures.
- Because of the freedom of data's form, the sql query may be heavy and complex.
- Time pressure ;(.


## The idea
At first define the main Entities : City, Utility, DataLog.
A City may have many Utility services, and each service has different DataLog's forms from different source (stream, upload, input manually). And, because data is power, so we should collect them all.
To support diversity of raw data, I define two types of attributes: Primary data field and Metadata.
 - **Primary Attributes**: a minimum required data (common data) to represent any kind of Utility.
 - **Metadata**: specific attributes of each Utility. Should be updated and weight by popularity.
  
The minimum validation here is Primary Attributes, which enough to create a record of amount utility services to be logged, metadata is extra info which will be stored in a pair of tables: **Metadata** and **MetadataValue**.

Basically: the relationship of objects should be: 
 - City has many Utility services.
 - Each services has it own metadata, which are grown by variety of import logs.
 - Fields are not Primary Attributes will be check if existing in database yet, if not they will be treated as a Metadata and are stored in Metadata table.

![alt text](/documentation/images/prisma-uml.png)

## Flow of data
  
  ```js
   /* Setup: */
    logPrimaryAttrs = ['amount', 'utility_id', 'logged_date', 'city_id']
    

   /* Input: */
    rawDataLog = { 
      amount: 500,
      utility_id : 1, // water supply
      logged_date : '2025-01-11',
      city_id : 1,
      quality : 'bad', 
      sample_amount: '100 litre'
    }

  /* Create DataLog. Output after processed:*/

    dataLog =  {
      id: 51,
      amount: 1000,
      utility_id : 1, // water supply
      logged_date : '2025-01-01',
      city_id : 1,
    }

    metadata = [
      {
        id: 1,
        utility_id: 1,
        name : 'is_verified',
      },
      {
        id: 2,
        utility_id: 1,
        name : 'usage',
      },
    ]

    metadataValue = [
      {
        id: 1,
        log_id: 1,
        metadata_id : 1,
        value : true
      },
      {
        id: 2,
        log_id: 1,
        metadata_id : 2,
        value : 'living'
      }
    ]

  ```
  
  To query log details of id 51, we combine
  ```sql
    SELECT * from DataLog WHERE id = 51 
  ```
  ![alt text](/documentation/images/queryDataLog.png)

  and
  ```sql
    SELECT m.name , v.value, m.unit
    FROM MetadataValue v 
    INNER JOIN Metadata m on v.metadata_id = m.id
    WHERE v.log_id = 51 ;
  ```
  ![alt text](/documentation/images/queryMetadata.png)

 Then we should have a full data look like (not implement yet)
 ```json
   /* Query */
    { "GET": "api/logs/51" }
   /* Response */
    { 
      "amount": 500,
      "utility_id" : 1, // water supply
      "logged_date" : "2025-01-11",
      "source": "manually",
      "city_id" : 1,
      "quality" : "bad", 
      "sample_amount": "100 litre"
    }
 ```

 or we can access partial metadata  (not implement yet)
 ```json
    /* Query */
    { "GET": "api/logs/51?metadata[]=quality" }
    
   /* Response*/
    { 
      "amount": 500,
      "utility_id" : 1, // water supply
      "logged_date" : "2025-01-11",
      "source": "manually",
      "city_id" : 1,
      "quality" : "bad" // only return quality
    }
 ```

We can also calculate total of a metadata, average values or options of specific metadata (by **metadata_id** of **MetadataValue** table) .

## UI overview
  ![Dashboard](/documentation/images/ui-overview-01.png)

  UI support basic tracking volume of Utilities.
  Displaying data of 10 latest days in two mode: chart or list.



![Import Logs](/documentation/images/ui-overview-02.png)
  Support import data by uploading .csv or manually input.
  Be able to map columns in `*.csv` to Primary Attributes (required fields).
 

## Benefits
 - Scalable: ready to support new City, Utility, DataLog formats.
 - Accessible: be able to access, manage, calculate each single metadata of selected Utility for analysis or report.


## Room for improvements
  The current sourcecode is lack of APIs that support analysis & improve usable of importing DataLog:

  - Get and map Metadata into DataLog.
  - Function that map utility's name to utility_id.
  - Function that map City to city_id.
  
  Also considering to use PostgreSQL by its excellent built-in JSON support (helpful to manipulate, indexing...)

  Should have some testing here...
 
  


  

   

  

   

    

  
